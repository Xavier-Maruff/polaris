
type Check(a) {
   Ctor1(val: a)
   Ctor2
}

type Field(a) {
    Field(val: a)
}

type Other {
    Other(val: nocrypt String)
}


pub fn check_inference(arg) {
    let b = Ok(12)
    let c = Err(arg) == b
    b
}

pub fn label_test(str: t, int: Int, tuple: #(String, Int)) {
    #(str, int)
}

pub fn main() {
    let b: nocrypt String = "test"
    let a: nocrypt String = b
    a |> check_inference
    check_inference(arg: a)
    check_inference(12)

    let q = label_test(int: 12, str: "test", tuple: #("test", 12))

    let b = 12
    let d = Ctor1(val: b)

    let map: Map(String, Int) = #{"key": 12, "key2": 12}

    let closure: fn(Int) -> Int = fn (x: Int) -> Int { x + 1 }
    let closure = fn (a) {Ctor1(val: a)}
    let ret = closure(b)
    let other_ret = fn (x: nocrypt String) { Ctor1(x) } (a)

    let some = Some(12)
    let unwrapped = some?

    let ok = Ok("test")
    let other = ok? |> Ctor1 |> Ctor1 |> Ctor1 |> Ctor1

    let test_param = Field(12)
    let param_val = test_param.val

    let test_match = Ctor1(12)
    let out = match test_match {
        Ctor1(val) -> val + 1,
        Ctor2 -> 0
    }

    let test_if = if True && False {
        12
    } else {
        0
    }

    out
}



pub fn check_pattern(val: Check(t)) {
    match val {
        Ctor1(v) -> v,
        Ctor2 -> 0
    }
}
