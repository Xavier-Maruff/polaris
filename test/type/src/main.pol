
type Check(a) {
   Ctor1(val: a)
   Ctor2
}

type Field(a) {
    Field(val: a)
}

type Other {
    Other(val: nocrypt String)
}

type AliasInt = Int
type AliasResult(a) = Result(a, String)
type AliasField = Field(Int)
type WrappedAlias(a) = #(AliasResult(a), Array(a))


pub fn check_inference(arg) {
    let b = Ok(12)
    let c = Err(arg) == b
    b
}

pub fn label_test(str: t, int: Int, tuple: #(String, Int)) {
    #(str, int)
}

pub fn alias_passthrough(val: AliasResult(t)) -> AliasResult(t) {
    val
}

pub fn main() {
    let b: nocrypt String = "test"
    let a: nocrypt String = b
    a |> check_inference
    check_inference(arg: a)
    check_inference(12)

    let q = label_test(int: 12, str: "test", tuple: #("test", 12))

    let b = 12
    let d = Ctor1(val: b)

    let map: Map(String, Int) = #{"key": 12, "key2": 12}

    let closure: fn(Int) -> Int = fn (x: Int) -> Int { x + 1 }
    let closure = fn (a) {Ctor1(val: a)}
    let ret = closure(b)
    let other_ret = fn (x: nocrypt String) { Ctor1(x) } (a)

    let some = Some(12)
    let unwrapped = some?

    let ok = Ok("test")
    let other = ok? |> Ctor1 |> Ctor1 |> Ctor1 |> Ctor1

    let test_param = Field(12)
    let param_val = test_param.val

    let test_match = Ctor1(12)
    let out = match test_match {
        Ctor1(val) -> val + 1,
        Ctor2 -> 0
    }

    let alias_val: AliasInt = 24
    let nocrypt_alias: nocrypt AliasInt = 42
    let alias_result: AliasResult(Int) = Ok(alias_val)
    let alias_field: AliasField = Field(val: alias_val)
    let _alias_field_val = alias_field.val
    let alias_tuple: WrappedAlias(Int) = #(alias_result, [alias_val])
    let alias_passthrough_fn: fn(AliasResult(Int)) -> AliasResult(Int) = alias_passthrough
    let alias_passthrough_result = alias_passthrough_fn(alias_result)
    let _nocrypt_alias_passthrough: AliasResult(nocrypt AliasInt) = Ok(nocrypt_alias)

    let test_if = if True && False {
        12
    } else {
        0
    }

    out
}

pub harness fn some_harness() -> Result(Int, String)
pub pure fn should_err() {
    let ret = some_harness()
    ret
}



pub fn check_pattern(val: Check(t)) {
    match val {
        Ctor1(v) -> v,
        Ctor2 -> 0
    }
}


pub fn taint_analysis() {
    let cond: Bool = True
    //should not error, as True is a literal so its nocrypt status can be inferred
    let b: nocrypt Int = if True { 12 } else { 0 }
    //should error, as cond is known to be an encrypted value
    //let c: nocrypt Int = if cond { 12 } else { 0 }
    //should error due to second-level taint
    //let d: nocrypt Int = if True { 12 } else { if cond { 0 } else { 5 }}


   //shouldn't error, as branch condition is a literal, and unification should propagate nocrypt
    let e: nocrypt Int = match Ctor1(12) {
        Ctor1(v) -> v,
        Ctor2 -> 0
    }

    //also shouldn't error, as f is not explicitly typed
    let e: nocrypt Check(Int) = Ctor1(12)
    let f = match e {
        Ctor1(v) -> v,
        Ctor2 -> 0
    }

    //should error, as match condition is tainted
    //let cond: Check(Int) = Ctor1(12)
    //let g: nocrypt Int = match cond {
    //    Ctor1(v) -> v,
    //    Ctor2 -> 0
    //}

    //should not error, as nocrypt should apply to all nested values
    let cond: nocrypt Check(Check(Int)) = Ctor1(Ctor1(12))
    let h: nocrypt Int = match cond {
        Ctor1(inner) -> match inner {
            Ctor1(v) -> v,
            Ctor2 -> 0
        },
        Ctor2 -> 0
    }

    //should error, as nested condition is tainted
    //let enc_bool: Bool = False
    //let out: nocrypt Int = match cond {
    //    Ctor1(inner) -> match enc_bool {
    //        True -> 12,
    //        False -> 0
    //    },
    //    Ctor2 -> 0
    //}
}
