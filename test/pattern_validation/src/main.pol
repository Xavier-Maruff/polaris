type TestEnum {
    Variant1(value: Int)
    Variant2
    Variant3(first: String, second: Bool)
}

fn test_basic_matching() -> Int {
    let x = 42
    match x {
        1 -> 10,
        42 -> 100,
        _ -> 0
    }
}

fn test_tuple_destructuring() -> Int {
    let pair = #(10, 20)
    match pair {
        #(a, b) -> a + b
    }
}

fn test_option_matching(opt: Option(Int)) -> Int {
    match opt {
        Some(x) -> x * 2,
        None -> -1
    }
}

fn test_nested_matching() -> String {
    let nested = Some(#(True, 42))
    match nested {
        None -> "nothing",
        Some(#(True, x)) -> "true case",
        Some(#(False, x)) -> "false case"
    }
}

fn test_list_patterns() -> Int {
    let numbers = [1, 2, 3]
    match numbers {
        [] -> 0,
        [single] -> single,
        [first, second] -> first + second,
        [first, ...rest] -> first * 10
    }
}

fn test_custom_enum(value: TestEnum) -> String {
    match value {
        Variant1(x) -> "variant1",
        Variant2 -> "variant2",
        Variant3(s, b) -> "variant3"
    }
}

fn main() -> Int {
    let basic = test_basic_matching()
    let tuple_result = test_tuple_destructuring()
    let option_result = test_option_matching(Some(5))
    let list_result = test_list_patterns()

    basic + tuple_result + option_result + list_result
}
